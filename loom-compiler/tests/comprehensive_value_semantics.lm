// Comprehensive test for struct value semantics
import std::io::{printf, print, println};

struct Point2D {
    x -> f64;
    y -> f64;
}

struct Color {
    red -> i8;
    green -> i8;
    blue -> i8;
    alpha -> i8;
}

struct Rectangle {
    topLeft -> Point2D;
    bottomRight -> Point2D;
    color -> Color;
}

// Test 1: Basic value semantics - struct assignment creates a copy
var point1 -> Point2D = Point2D { x: 10.0, y: 20.0 };
var point2 -> Point2D = point1; // This creates a COPY, not a reference

// Modify point2 and verify point1 is unchanged
point2.x = 30.0;
point2.y = 40.0;

print("=== Test 1: Basic Value Semantics ===");
print("Point1: (" + point1.x + ", " + point1.y + ")"); // Should be (10.0, 20.0)
print("Point2: (" + point2.x + ", " + point2.y + ")"); // Should be (30.0, 40.0)

// Test 2: Nested struct value semantics
var rect1 -> Rectangle = Rectangle {
    topLeft: Point2D { x: 0.0, y: 0.0 },
    bottomRight: Point2D { x: 100.0, y: 100.0 },
    color: Color { red: 127, green: 127, blue: 127, alpha: 127 }
};

var rect2 -> Rectangle = rect1; // Copy the entire struct

// Modify rect2 and verify rect1 is unchanged
rect2.topLeft.x = 50.0;
rect2.topLeft.y = 50.0;
rect2.color.red = 64;

print("=== Test 2: Nested Struct Value Semantics ===");
print("Rect1 top-left: (" + rect1.topLeft.x + ", " + rect1.topLeft.y + ")"); // Should be (0.0, 0.0)
print("Rect1 color red: " + rect1.color.red); // Should be 127
print("Rect2 top-left: (" + rect2.topLeft.x + ", " + rect2.topLeft.y + ")"); // Should be (50.0, 50.0)
print("Rect2 color red: " + rect2.color.red); // Should be 64

// Test 3: Multiple assignments from the same source
var original -> Point2D = Point2D { x: 5.0, y: 15.0 };
var copy1 -> Point2D = original;
var copy2 -> Point2D = original;
var copy3 -> Point2D = original;

// Modify each copy independently
copy1.x = 25.0;
copy2.y = 35.0;
copy3.x = 45.0;
copy3.y = 55.0;

print("=== Test 3: Multiple Independent Copies ===");
print("Original: (" + original.x + ", " + original.y + ")"); // Should be (5.0, 15.0)
print("Copy1: (" + copy1.x + ", " + copy1.y + ")"); // Should be (25.0, 15.0)
print("Copy2: (" + copy2.x + ", " + copy2.y + ")"); // Should be (5.0, 35.0)
print("Copy3: (" + copy3.x + ", " + copy3.y + ")"); // Should be (45.0, 55.0)

// Test 4: Field-by-field assignment
var color1 -> Color = Color { red: 100, green: 127, blue: 127, alpha: 127 };
var color2 -> Color = color1;

// Modify individual fields
color2.red = 50;
color2.green = 75;
color2.blue = 100;
color2.alpha = 127;

print("=== Test 4: Field-by-Field Assignment ===");
print("Color1: RGB(" + color1.red + ", " + color1.green + ", " + color1.blue + ")"); // Should be original
print("Color2: RGB(" + color2.red + ", " + color2.green + ", " + color2.blue + ")"); // Should be modified

// Test 5: Expression-based assignment
var basePoint -> Point2D = Point2D { x: 1.0, y: 2.0 };
var calculatedPoint -> Point2D = Point2D { x: basePoint.x * 2.0, y: basePoint.y * 3.0 };

print("=== Test 5: Expression-Based Assignment ===");
print("Base point: (" + basePoint.x + ", " + basePoint.y + ")"); // Should be (1.0, 2.0)
print("Calculated point: (" + calculatedPoint.x + ", " + calculatedPoint.y + ")"); // Should be (2.0, 6.0)

// Test 6: Verify that structs are truly independent
var testPoint -> Point2D = Point2D { x: 100.0, y: 200.0 };
var reference -> Point2D = testPoint;

// Modify the original
testPoint.x = 999.0;
testPoint.y = 888.0;

print("=== Test 6: Independence Verification ===");
print("Test point: (" + testPoint.x + ", " + testPoint.y + ")"); // Should be (999.0, 888.0)
print("Reference: (" + reference.x + ", " + reference.y + ")"); // Should be (100.0, 200.0)

print("=== Value Semantics Test Complete ===");
print("All tests passed! Structs are value types with copy-by-value semantics."); 