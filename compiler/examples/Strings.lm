mod examples

# Strings in Loom
# ----------------
# - `string` is a first-class, immutable sequence of Unicode scalar values, encoded as UTF-8.
# - Iterating a `string` yields `char` (Unicode scalars), not raw bytes.
# - Use `+` to concatenate strings and to concatenate string + char (char is promoted).
# - Indexing is in terms of Unicode scalars (code points), not bytes.
# - For raw byte access, convert to `[]byte` explicitly via std helpers.
# - Nullability: `string` itself is non-null; use `string?` for optional strings.
#
# Common operations (assumed provided by std):
#   str.lengthBytes(): i32         # UTF-8 byte length
#   str.charLength(): i32          # number of Unicode scalars
#   str.isEmpty(): bool
#   str.charAt(i: i32): char       # 0-based code-point index
#   str.sliceChars(start: i32, end: i32): string   # [start, end)
#   str.indexOf(sub: string): i32  # char index or -1 if not found
#   str.contains(sub: string): bool
#   str.startsWith(prefix: string): bool
#   str.endsWith(suffix: string): bool
#   str.trim(): string
#   str.toLower(): string
#   str.toUpper(): string
#
# Interop helpers (std.str):
#   std.str.fromChars(chars: []char): string
#   std.str.toChars(s: string): []char
#   std.str.fromBytes(bytes: []byte): string        # validates UTF-8
#   std.str.toBytes(s: string): []byte              # UTF-8 encoding
#
# For many concatenations, prefer a builder:
#   std.str.Builder (append(string|char|i32|â€¦)->Builder, toString()->string)
#
# NOTE: This file assumes the above API; adjust names as your stdlib solidifies.

pub func main(argc: []i32, argv: []string): void {

    # --- Literals & Escapes ---
    let hello: string = "Hello"
    let world: string = "World"
    let quote: string = "He said: \"Loom rocks!\""
    let path: string = "C:\\Users\\dev"     # backslash escape
    let emoji: string = "ðŸš€"                 # astral char in a string
    let mixed: string = "A, Ã©, ä¸­, ðŸ˜€"       # mixed BMP/astral

    std.system.io.printl(hello)
    std.system.io.printl(quote)
    std.system.io.printl(path)
    std.system.io.printl(mixed)

    # --- Concatenation ---
    let greet: string = hello + ", " + world + "!"
    std.system.io.printl(greet)

    # char promotes to string in concat
    let exclaim: char = '!'
    let greet2: string = hello + ' ' + world + exclaim
    std.system.io.printl(greet2)

    # --- Lengths (bytes vs chars) ---
    std.system.io.printl("hello bytes=" + hello.lengthBytes() +
                         ", chars=" + hello.charLength())

    std.system.io.printl("emoji bytes=" + emoji.lengthBytes() +
                         ", chars=" + emoji.charLength())
    # Expect: emoji.bytes >= 4, emoji.chars == 1

    std.system.io.printl("mixed bytes=" + mixed.lengthBytes() +
                         ", chars=" + mixed.charLength())

    # --- Indexing by char (code point), not byte ---
    # Access the 0th char of "Hello"
    let first: char = hello.charAt(0)            # 'H'
    let last:  char = hello.charAt(hello.charLength() - 1)  # 'o'
    std.system.io.printl("first=" + first + ", last=" + last)

    # Safe slice by char range (half-open)
    let lo: string = hello.sliceChars(3, 5)      # "lo"
    std.system.io.printl("slice 'lo' = " + lo)

    # --- Searching ---
    std.system.io.printl("'Hello' contains 'ell'? " + (hello.contains("ell") ? "yes" : "no"))
    std.system.io.printl("'Hello' indexOf 'l'? = " + hello.indexOf("l"))
    std.system.io.printl("'Hello' startsWith 'He'? " + (hello.startsWith("He") ? "yes" : "no"))
    std.system.io.printl("'World' endsWith 'ld'? " + (world.endsWith("ld") ? "yes" : "no"))

    # --- Trimming / Case ---
    let spaced: string = "   Loom \t\n"
    std.system.io.printl("trim: '" + spaced.trim() + "'")
    std.system.io.printl("upper: " + hello.toUpper())
    std.system.io.printl("lower: " + world.toLower())

    # --- Interop with []char ---
    let chars: []char = ['L', 'o', 'o', 'm', ' ', 'ðŸš€']
    let fromChars: string = std.str.fromChars(chars)
    std.system.io.printl("fromChars: " + fromChars)

    let backToChars: []char = std.str.toChars(fromChars)
    std.system.io.printl("backToChars length=" + backToChars.length())

    # --- Interop with []byte (UTF-8) ---
    let bytes: []byte = std.str.toBytes("Î©mega")    # encoded UTF-8
    let again: string = std.str.fromBytes(bytes)    # validated UTF-8
    std.system.io.printl("fromBytes: " + again)

    # --- String builder for efficient concatenation ---
    # Pseudocode API, adjust to your stdlib naming.
    let builder = std.str.Builder()
    builder.append("Fibonacci: ")
    builder.append('[')

    var a: i32 = 0
    var b: i32 = 1
    loop (i: 0..10) {
        builder.append(a)
        if (i < 10) builder.append(", ")
        let next = a + b
        a = b
        b = next
    }
    builder.append(']')

    let fibLine: string = builder.toString()
    std.system.io.printl(fibLine)

    # --- Optional strings (nullable) ---
    let maybe: string? = null
    if (maybe == null) {
        std.system.io.printl("maybe is null")
    }
    # laterâ€¦
    # maybe = "set"
    # std.system.io.printl("maybe=" + maybe!)  # non-null assert

    # --- Unicode safety note ---
    # `charAt` and `sliceChars` operate on Unicode scalars.
    # If you need grapheme clusters (user-perceived characters), provide
    # std.str.grapheme* APIs at a higher level (locale-aware), e.g.:
    #   s.graphemeLength(), s.graphemeAt(i), s.sliceGraphemes(start, end)
}

# (Optional) Suggested signatures for std helpers referenced above:
#
# namespace std.str {
#   pub func fromChars(chars: []char): string
#   pub func toChars(s: string): []char
#   pub func fromBytes(bytes: []byte): string      # validates UTF-8, error on invalid
#   pub func toBytes(s: string): []byte
#
#   pub class Builder {
#       pub builder()
#       pub func append(s: string): Builder
#       pub func append(c: char): Builder
#       pub func append(n: i32): Builder           # overloads for common primitives
#       pub func toString(): string
#   }
# }
